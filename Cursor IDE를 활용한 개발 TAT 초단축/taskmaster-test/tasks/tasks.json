{
  "tasks": [
    {
      "id": 1,
      "title": "Setup Project Structure and Environment",
      "description": "Initialize the project repository with basic structure and required dependencies for Python 3.8+",
      "details": "1. Create a new Python project with the following structure:\n```\nnkwiki/\n  ├── nkwiki/\n  │   ├── __init__.py\n  │   ├── analyzer/\n  │   │   └── __init__.py\n  │   ├── generator/\n  │   │   └── __init__.py\n  │   └── cli/\n  │       └── __init__.py\n  ├── tests/\n  │   └── __init__.py\n  ├── setup.py\n  ├── requirements.txt\n  ├── README.md\n  └── LICENSE\n```\n2. Setup virtual environment with Python 3.8+\n3. Add initial dependencies to requirements.txt:\n   - ast (standard library)\n   - markdown\n   - mdx_gfm\n   - pytest (for testing)\n4. Create setup.py with basic project metadata\n5. Initialize git repository",
      "testStrategy": "1. Verify project structure is correctly set up\n2. Ensure all dependencies can be installed in a clean environment\n3. Confirm Python 3.8+ compatibility\n4. Validate that the package can be installed in development mode with `pip install -e .`",
      "priority": "high",
      "dependencies": [],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "Create Project Directory Structure",
          "description": "Set up the initial directory structure for the nkwiki project with all required folders and empty __init__.py files.",
          "dependencies": [],
          "details": "Create the main project directory 'nkwiki' and all subdirectories as specified in the structure. Create empty __init__.py files in each package directory to make them proper Python packages. This includes the main package directory, analyzer, generator, cli, and tests directories.",
          "status": "pending",
          "testStrategy": "Verify all directories and files exist in the correct structure using a simple script that checks for the presence of each path."
        },
        {
          "id": 2,
          "title": "Setup Python Virtual Environment",
          "description": "Create and configure a Python virtual environment for the project using Python 3.8+.",
          "dependencies": [
            1
          ],
          "details": "Use 'python -m venv venv' to create a virtual environment in the project root. Create activation scripts documentation in README.md for different platforms (Windows, macOS, Linux). Ensure the virtual environment is excluded from version control by adding 'venv/' to .gitignore.",
          "status": "pending",
          "testStrategy": "Verify the virtual environment can be activated and Python 3.8+ is available by running 'python --version'."
        },
        {
          "id": 3,
          "title": "Create Requirements and Setup Files",
          "description": "Create requirements.txt with initial dependencies and setup.py with project metadata.",
          "dependencies": [
            1
          ],
          "details": "Create requirements.txt with the specified dependencies: markdown, mdx_gfm, and pytest. Create setup.py with project metadata including name, version, description, author, license, and package dependencies. Use setuptools and define the project as a package with its subpackages.",
          "status": "pending",
          "testStrategy": "Verify requirements can be installed with 'pip install -r requirements.txt' and the package can be installed in development mode with 'pip install -e .'."
        },
        {
          "id": 4,
          "title": "Create Documentation Files",
          "description": "Create README.md and LICENSE files with appropriate content.",
          "dependencies": [
            1
          ],
          "details": "Create a README.md with sections for: project description, installation instructions, usage examples, and development setup. Choose and add an appropriate open-source license file (e.g., MIT, Apache, GPL) based on project requirements. Include information about the purpose of each package in the README.",
          "status": "pending",
          "testStrategy": "Verify README.md renders correctly on a Markdown previewer and contains all required sections."
        },
        {
          "id": 5,
          "title": "Initialize Git Repository",
          "description": "Initialize a Git repository for the project with appropriate configuration.",
          "dependencies": [
            1,
            2,
            3,
            4
          ],
          "details": "Initialize a Git repository with 'git init'. Create a .gitignore file with common Python patterns (pycache, venv, dist, build, etc.). Make an initial commit with all the created files. Configure git user information if needed. Create a main/master branch according to preferred workflow.",
          "status": "pending",
          "testStrategy": "Verify the repository is properly initialized with 'git status' and all files are tracked except those specified in .gitignore."
        }
      ]
    },
    {
      "id": 2,
      "title": "Implement Code Analysis Engine for Python",
      "description": "Develop the core code analysis engine that can parse Python source code and extract class, function, and module structures",
      "details": "1. Create analyzer module with the following components:\n```python\n# nkwiki/analyzer/python_analyzer.py\nimport ast\nimport os\nfrom typing import Dict, List, Any\n\nclass PythonAnalyzer:\n    def __init__(self, path: str):\n        self.path = path\n        self.modules = {}\n    \n    def analyze_file(self, file_path: str) -> Dict[str, Any]:\n        \"\"\"Analyze a single Python file and extract its structure\"\"\"\n        with open(file_path, 'r', encoding='utf-8') as f:\n            content = f.read()\n        \n        tree = ast.parse(content)\n        module_info = {\n            'classes': self._extract_classes(tree),\n            'functions': self._extract_functions(tree),\n            'docstring': ast.get_docstring(tree),\n            'imports': self._extract_imports(tree)\n        }\n        return module_info\n    \n    def _extract_classes(self, tree: ast.AST) -> List[Dict[str, Any]]:\n        \"\"\"Extract class definitions from AST\"\"\"\n        # Implementation details\n        pass\n    \n    def _extract_functions(self, tree: ast.AST) -> List[Dict[str, Any]]:\n        \"\"\"Extract function definitions from AST\"\"\"\n        # Implementation details\n        pass\n    \n    def _extract_imports(self, tree: ast.AST) -> List[Dict[str, Any]]:\n        \"\"\"Extract import statements from AST\"\"\"\n        # Implementation details\n        pass\n    \n    def analyze_directory(self, dir_path: str = None) -> Dict[str, Any]:\n        \"\"\"Recursively analyze Python files in a directory\"\"\"\n        if dir_path is None:\n            dir_path = self.path\n        \n        result = {}\n        for root, _, files in os.walk(dir_path):\n            for file in files:\n                if file.endswith('.py'):\n                    file_path = os.path.join(root, file)\n                    rel_path = os.path.relpath(file_path, self.path)\n                    result[rel_path] = self.analyze_file(file_path)\n        \n        return result\n```\n\n2. Implement helper functions to extract docstrings, type hints, and other metadata\n3. Add support for detecting class inheritance and method overrides\n4. Implement function to identify module relationships and dependencies",
      "testStrategy": "1. Create unit tests with sample Python files containing various structures (classes, functions, nested classes, etc.)\n2. Test with files containing different docstring formats (Google style, NumPy style, etc.)\n3. Verify correct extraction of:\n   - Class definitions and inheritance\n   - Function signatures and docstrings\n   - Module-level docstrings and imports\n4. Test with edge cases like empty files, files with syntax errors, and large files",
      "priority": "high",
      "dependencies": [
        1
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 3,
      "title": "Implement Project Structure Analyzer",
      "description": "Create a component to analyze project directory structure and identify configuration files",
      "details": "1. Create a project structure analyzer module:\n```python\n# nkwiki/analyzer/project_analyzer.py\nimport os\nfrom typing import Dict, List, Any\n\nclass ProjectAnalyzer:\n    def __init__(self, path: str):\n        self.path = path\n        self.config_patterns = {\n            'python': ['requirements.txt', 'setup.py', 'pyproject.toml', 'Pipfile'],\n            'node': ['package.json', 'package-lock.json', 'yarn.lock'],\n            'general': ['.gitignore', 'README.md', 'LICENSE', 'Dockerfile']\n        }\n    \n    def analyze_structure(self) -> Dict[str, Any]:\n        \"\"\"Analyze the project directory structure\"\"\"\n        structure = {\n            'directories': [],\n            'config_files': [],\n            'hierarchy': self._build_hierarchy(self.path)\n        }\n        \n        # Collect directories\n        for root, dirs, _ in os.walk(self.path):\n            rel_path = os.path.relpath(root, self.path)\n            if rel_path != '.':\n                structure['directories'].append(rel_path)\n        \n        # Identify config files\n        structure['config_files'] = self._find_config_files()\n        \n        return structure\n    \n    def _build_hierarchy(self, path: str, rel_path: str = '') -> Dict[str, Any]:\n        \"\"\"Build a hierarchical representation of the directory structure\"\"\"\n        result = {'name': os.path.basename(path) or path, 'type': 'dir', 'children': []}\n        \n        for item in os.listdir(path):\n            item_path = os.path.join(path, item)\n            item_rel_path = os.path.join(rel_path, item)\n            \n            if os.path.isdir(item_path) and not item.startswith('.'):\n                result['children'].append(self._build_hierarchy(item_path, item_rel_path))\n            elif os.path.isfile(item_path):\n                result['children'].append({\n                    'name': item,\n                    'type': 'file',\n                    'path': item_rel_path\n                })\n        \n        return result\n    \n    def _find_config_files(self) -> List[Dict[str, str]]:\n        \"\"\"Find configuration files in the project\"\"\"\n        config_files = []\n        \n        for root, _, files in os.walk(self.path):\n            for file in files:\n                for category, patterns in self.config_patterns.items():\n                    if file in patterns:\n                        file_path = os.path.join(root, file)\n                        rel_path = os.path.relpath(file_path, self.path)\n                        config_files.append({\n                            'name': file,\n                            'path': rel_path,\n                            'category': category\n                        })\n        \n        return config_files\n```\n\n2. Add methods to detect project type based on configuration files\n3. Implement functions to extract metadata from common configuration files\n4. Add support for identifying test directories and source directories",
      "testStrategy": "1. Create test projects with various directory structures\n2. Test with projects containing different configuration files (requirements.txt, package.json, etc.)\n3. Verify correct identification of:\n   - Project hierarchy\n   - Configuration files and their categories\n   - Project type detection\n4. Test with edge cases like empty directories, deeply nested structures, and projects with unusual layouts",
      "priority": "medium",
      "dependencies": [
        1
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 4,
      "title": "Implement Markdown Document Generator",
      "description": "Create a component that generates Markdown documentation from the analyzed code structure",
      "details": "1. Create a document generator module:\n```python\n# nkwiki/generator/markdown_generator.py\nimport os\nfrom typing import Dict, List, Any\n\nclass MarkdownGenerator:\n    def __init__(self, analysis_data: Dict[str, Any], output_dir: str):\n        self.analysis_data = analysis_data\n        self.output_dir = output_dir\n        \n    def generate_documentation(self) -> None:\n        \"\"\"Generate markdown documentation from analysis data\"\"\"\n        os.makedirs(self.output_dir, exist_ok=True)\n        \n        # Generate project overview\n        self._generate_overview()\n        \n        # Generate module documentation\n        self._generate_modules_docs()\n        \n        # Generate index file\n        self._generate_index()\n    \n    def _generate_overview(self) -> None:\n        \"\"\"Generate project overview documentation\"\"\"\n        overview_path = os.path.join(self.output_dir, 'overview.md')\n        \n        with open(overview_path, 'w', encoding='utf-8') as f:\n            f.write('# Project Overview\\n\\n')\n            \n            # Project structure section\n            f.write('## Project Structure\\n\\n')\n            f.write('```\\n')\n            f.write(self._format_directory_tree(self.analysis_data['project']['hierarchy']))\n            f.write('```\\n\\n')\n            \n            # Configuration files section\n            f.write('## Configuration Files\\n\\n')\n            for config in self.analysis_data['project']['config_files']:\n                f.write(f'- **{config[\"name\"]}**: {config[\"path\"]}\\n')\n    \n    def _generate_modules_docs(self) -> None:\n        \"\"\"Generate documentation for each module\"\"\"\n        modules_dir = os.path.join(self.output_dir, 'modules')\n        os.makedirs(modules_dir, exist_ok=True)\n        \n        for module_path, module_data in self.analysis_data['code'].items():\n            module_name = os.path.splitext(os.path.basename(module_path))[0]\n            file_path = os.path.join(modules_dir, f'{module_name}.md')\n            \n            with open(file_path, 'w', encoding='utf-8') as f:\n                f.write(f'# Module: {module_name}\\n\\n')\n                \n                # Module docstring\n                if module_data.get('docstring'):\n                    f.write(f'{module_data[\"docstring\"]}\\n\\n')\n                \n                # Classes\n                if module_data.get('classes'):\n                    f.write('## Classes\\n\\n')\n                    for class_info in module_data['classes']:\n                        self._write_class_doc(f, class_info)\n                \n                # Functions\n                if module_data.get('functions'):\n                    f.write('## Functions\\n\\n')\n                    for func_info in module_data['functions']:\n                        self._write_function_doc(f, func_info)\n    \n    def _write_class_doc(self, file, class_info: Dict[str, Any]) -> None:\n        \"\"\"Write documentation for a class\"\"\"\n        file.write(f'### {class_info[\"name\"]}\\n\\n')\n        \n        if class_info.get('docstring'):\n            file.write(f'{class_info[\"docstring\"]}\\n\\n')\n        \n        if class_info.get('methods'):\n            file.write('#### Methods\\n\\n')\n            for method in class_info['methods']:\n                file.write(f'##### `{method[\"name\"]}`\\n\\n')\n                if method.get('docstring'):\n                    file.write(f'{method[\"docstring\"]}\\n\\n')\n                file.write(f'```python\\n{method[\"signature\"]}\\n```\\n\\n')\n    \n    def _write_function_doc(self, file, func_info: Dict[str, Any]) -> None:\n        \"\"\"Write documentation for a function\"\"\"\n        file.write(f'### `{func_info[\"name\"]}`\\n\\n')\n        \n        if func_info.get('docstring'):\n            file.write(f'{func_info[\"docstring\"]}\\n\\n')\n        \n        file.write(f'```python\\n{func_info[\"signature\"]}\\n```\\n\\n')\n    \n    def _generate_index(self) -> None:\n        \"\"\"Generate index file\"\"\"\n        index_path = os.path.join(self.output_dir, 'index.md')\n        \n        with open(index_path, 'w', encoding='utf-8') as f:\n            f.write('# Documentation Index\\n\\n')\n            f.write('- [Project Overview](overview.md)\\n')\n            f.write('- Modules:\\n')\n            \n            for module_path in self.analysis_data['code'].keys():\n                module_name = os.path.splitext(os.path.basename(module_path))[0]\n                f.write(f'  - [{module_name}](modules/{module_name}.md)\\n')\n    \n    def _format_directory_tree(self, node: Dict[str, Any], prefix: str = '') -> str:\n        \"\"\"Format directory tree as a string\"\"\"\n        result = []\n        name = node['name']\n        \n        if prefix:\n            result.append(f\"{prefix}└── {name}\")\n        else:\n            result.append(name)\n        \n        prefix = prefix + \"    \"\n        \n        for i, child in enumerate(node.get('children', [])):\n            is_last = i == len(node.get('children', [])) - 1\n            if child['type'] == 'dir':\n                result.append(self._format_directory_tree(child, prefix))\n            else:\n                result.append(f\"{prefix}└── {child['name']}\")\n        \n        return '\\n'.join(result)\n```\n\n2. Implement formatting helpers for different documentation elements\n3. Add support for syntax highlighting in code blocks\n4. Create templates for different documentation sections",
      "testStrategy": "1. Test with sample analysis data from the code analyzer\n2. Verify correct generation of:\n   - Project overview documentation\n   - Module documentation with classes and functions\n   - Index file with proper links\n3. Check formatting of generated markdown for proper syntax\n4. Validate that code blocks have proper syntax highlighting\n5. Test with edge cases like modules with no docstrings, empty classes, etc.",
      "priority": "high",
      "dependencies": [
        2,
        3
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 5,
      "title": "Implement CLI Interface",
      "description": "Create a command-line interface for the tool with basic commands for analysis and document generation",
      "details": "1. Create a CLI module using argparse:\n```python\n# nkwiki/cli/main.py\nimport argparse\nimport os\nimport sys\nfrom typing import List, Optional\n\nfrom nkwiki.analyzer.python_analyzer import PythonAnalyzer\nfrom nkwiki.analyzer.project_analyzer import ProjectAnalyzer\nfrom nkwiki.generator.markdown_generator import MarkdownGenerator\n\ndef parse_args(args: Optional[List[str]] = None) -> argparse.Namespace:\n    \"\"\"Parse command line arguments\"\"\"\n    parser = argparse.ArgumentParser(\n        description='nkwiki: Automatic codebase documentation tool'\n    )\n    \n    subparsers = parser.add_subparsers(dest='command', help='Command to execute')\n    \n    # Analyze command\n    analyze_parser = subparsers.add_parser('analyze', help='Analyze code without generating docs')\n    analyze_parser.add_argument('path', help='Path to the code directory or file')\n    analyze_parser.add_argument('-o', '--output', help='Output JSON file for analysis results')\n    \n    # Generate command\n    generate_parser = subparsers.add_parser('generate', help='Generate documentation')\n    generate_parser.add_argument('path', help='Path to the code directory or file')\n    generate_parser.add_argument('-o', '--output', default='./docs', help='Output directory for documentation')\n    generate_parser.add_argument('-f', '--format', default='markdown', choices=['markdown'], \n                                help='Documentation format (only markdown supported for now)')\n    \n    # Version command\n    version_parser = subparsers.add_parser('version', help='Show version information')\n    \n    return parser.parse_args(args)\n\ndef main(args: Optional[List[str]] = None) -> int:\n    \"\"\"Main entry point for the CLI\"\"\"\n    parsed_args = parse_args(args)\n    \n    if parsed_args.command == 'version':\n        from nkwiki import __version__\n        print(f'nkwiki version {__version__}')\n        return 0\n    \n    if parsed_args.command == 'analyze':\n        return analyze_command(parsed_args)\n    \n    if parsed_args.command == 'generate':\n        return generate_command(parsed_args)\n    \n    # No command specified, show help\n    parse_args(['--help'])\n    return 1\n\ndef analyze_command(args: argparse.Namespace) -> int:\n    \"\"\"Execute the analyze command\"\"\"\n    path = os.path.abspath(args.path)\n    \n    if not os.path.exists(path):\n        print(f\"Error: Path '{path}' does not exist\", file=sys.stderr)\n        return 1\n    \n    print(f\"Analyzing code at '{path}'...\")\n    \n    # Analyze project structure\n    project_analyzer = ProjectAnalyzer(path)\n    project_data = project_analyzer.analyze_structure()\n    \n    # Analyze Python code\n    python_analyzer = PythonAnalyzer(path)\n    code_data = python_analyzer.analyze_directory()\n    \n    analysis_data = {\n        'project': project_data,\n        'code': code_data\n    }\n    \n    if args.output:\n        import json\n        with open(args.output, 'w', encoding='utf-8') as f:\n            json.dump(analysis_data, f, indent=2)\n        print(f\"Analysis results saved to '{args.output}'\")\n    else:\n        import json\n        print(json.dumps(analysis_data, indent=2))\n    \n    return 0\n\ndef generate_command(args: argparse.Namespace) -> int:\n    \"\"\"Execute the generate command\"\"\"\n    path = os.path.abspath(args.path)\n    output_dir = os.path.abspath(args.output)\n    \n    if not os.path.exists(path):\n        print(f\"Error: Path '{path}' does not exist\", file=sys.stderr)\n        return 1\n    \n    print(f\"Analyzing code at '{path}'...\")\n    \n    # Analyze project structure\n    project_analyzer = ProjectAnalyzer(path)\n    project_data = project_analyzer.analyze_structure()\n    \n    # Analyze Python code\n    python_analyzer = PythonAnalyzer(path)\n    code_data = python_analyzer.analyze_directory()\n    \n    analysis_data = {\n        'project': project_data,\n        'code': code_data\n    }\n    \n    print(f\"Generating documentation in '{output_dir}'...\")\n    \n    # Generate documentation\n    if args.format == 'markdown':\n        generator = MarkdownGenerator(analysis_data, output_dir)\n        generator.generate_documentation()\n    \n    print(f\"Documentation generated successfully in '{output_dir}'\")\n    return 0\n\nif __name__ == '__main__':\n    sys.exit(main())\n```\n\n2. Create an entry point in setup.py:\n```python\nsetup(\n    # ... other setup parameters ...\n    entry_points={\n        'console_scripts': [\n            'nkwiki=nkwiki.cli.main:main',\n        ],\n    },\n)\n```\n\n3. Implement version handling in __init__.py:\n```python\n# nkwiki/__init__.py\n__version__ = '0.1.0'\n```\n\n4. Add error handling and logging throughout the CLI interface",
      "testStrategy": "1. Test each CLI command with various arguments\n2. Verify correct handling of:\n   - Valid and invalid paths\n   - Different output formats\n   - Missing arguments\n3. Test the analyze command with sample projects\n4. Test the generate command with sample projects\n5. Verify that the CLI returns appropriate exit codes\n6. Test help and version commands",
      "priority": "high",
      "dependencies": [
        2,
        3,
        4
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 6,
      "title": "Implement Code Example Extraction",
      "description": "Add functionality to extract code examples from docstrings and generate sample usage documentation",
      "details": "1. Create a code example extractor module:\n```python\n# nkwiki/analyzer/example_extractor.py\nimport re\nfrom typing import List, Dict, Any, Optional\n\nclass ExampleExtractor:\n    def __init__(self):\n        # Regex patterns for different docstring formats\n        self.patterns = {\n            'python_doctest': r'\\s*>>>\\s+(.+)(?:\\s+\\.\\.\\.\\s+(.+))*(?:\\s+(.+))?',\n            'code_block': r'```(?:python)?\\n([\\s\\S]+?)\\n```',\n            'example_section': r'(?:Examples?|Usage):\\s*\\n([\\s\\S]+?)(?:\\n\\n|$)'\n        }\n    \n    def extract_examples(self, docstring: Optional[str]) -> List[Dict[str, Any]]:\n        \"\"\"Extract code examples from a docstring\"\"\"\n        if not docstring:\n            return []\n        \n        examples = []\n        \n        # Extract doctests\n        doctest_examples = self._extract_doctests(docstring)\n        if doctest_examples:\n            examples.extend(doctest_examples)\n        \n        # Extract code blocks\n        code_block_examples = self._extract_code_blocks(docstring)\n        if code_block_examples:\n            examples.extend(code_block_examples)\n        \n        # Extract from example sections\n        example_sections = self._extract_example_sections(docstring)\n        if example_sections:\n            examples.extend(example_sections)\n        \n        return examples\n    \n    def _extract_doctests(self, docstring: str) -> List[Dict[str, Any]]:\n        \"\"\"Extract Python doctests from a docstring\"\"\"\n        examples = []\n        pattern = self.patterns['python_doctest']\n        \n        matches = re.finditer(pattern, docstring, re.MULTILINE)\n        for match in matches:\n            code = match.group(1)\n            examples.append({\n                'type': 'doctest',\n                'code': code,\n                'output': match.group(3) if match.group(3) else None\n            })\n        \n        return examples\n    \n    def _extract_code_blocks(self, docstring: str) -> List[Dict[str, Any]]:\n        \"\"\"Extract code blocks from a docstring\"\"\"\n        examples = []\n        pattern = self.patterns['code_block']\n        \n        matches = re.finditer(pattern, docstring, re.MULTILINE)\n        for match in matches:\n            code = match.group(1).strip()\n            examples.append({\n                'type': 'code_block',\n                'code': code,\n                'output': None\n            })\n        \n        return examples\n    \n    def _extract_example_sections(self, docstring: str) -> List[Dict[str, Any]]:\n        \"\"\"Extract examples from dedicated example sections\"\"\"\n        examples = []\n        pattern = self.patterns['example_section']\n        \n        matches = re.finditer(pattern, docstring, re.MULTILINE)\n        for match in matches:\n            content = match.group(1).strip()\n            examples.append({\n                'type': 'example_section',\n                'code': content,\n                'output': None\n            })\n        \n        return examples\n```\n\n2. Integrate the example extractor with the Python analyzer:\n```python\n# In PythonAnalyzer class\nfrom nkwiki.analyzer.example_extractor import ExampleExtractor\n\ndef __init__(self, path: str):\n    self.path = path\n    self.modules = {}\n    self.example_extractor = ExampleExtractor()\n\ndef _extract_functions(self, tree: ast.AST) -> List[Dict[str, Any]]:\n    functions = []\n    for node in ast.iter_child_nodes(tree):\n        if isinstance(node, ast.FunctionDef):\n            docstring = ast.get_docstring(node)\n            examples = self.example_extractor.extract_examples(docstring)\n            \n            functions.append({\n                'name': node.name,\n                'docstring': docstring,\n                'signature': self._get_function_signature(node),\n                'examples': examples\n            })\n    return functions\n```\n\n3. Update the markdown generator to include examples in the documentation:\n```python\n# In MarkdownGenerator._write_function_doc method\ndef _write_function_doc(self, file, func_info: Dict[str, Any]) -> None:\n    \"\"\"Write documentation for a function\"\"\"\n    file.write(f'### `{func_info[\"name\"]}`\\n\\n')\n    \n    if func_info.get('docstring'):\n        file.write(f'{func_info[\"docstring\"]}\\n\\n')\n    \n    file.write(f'```python\\n{func_info[\"signature\"]}\\n```\\n\\n')\n    \n    # Add examples section if available\n    if func_info.get('examples'):\n        file.write('#### Examples\\n\\n')\n        for example in func_info['examples']:\n            file.write('```python\\n')\n            file.write(example['code'])\n            file.write('\\n```\\n\\n')\n            if example.get('output'):\n                file.write('Output:\\n```\\n')\n                file.write(example['output'])\n                file.write('\\n```\\n\\n')\n```",
      "testStrategy": "1. Create test cases with docstrings containing various example formats:\n   - Python doctests\n   - Markdown code blocks\n   - Example sections\n2. Verify correct extraction of examples from each format\n3. Test with edge cases like malformed examples, nested code blocks, etc.\n4. Verify that extracted examples are correctly included in generated documentation\n5. Test with real-world docstrings from popular Python libraries",
      "priority": "medium",
      "dependencies": [
        2,
        4
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 7,
      "title": "Implement Git Repository Support",
      "description": "Add support for analyzing Git repositories by URL or local Git repository",
      "details": "1. Add GitPython to requirements.txt\n2. Create a Git repository analyzer module:\n```python\n# nkwiki/analyzer/git_analyzer.py\nimport os\nimport tempfile\nimport shutil\nfrom typing import Dict, Any, Optional\nimport git\n\nclass GitAnalyzer:\n    def __init__(self, repo_url: str, branch: str = 'main'):\n        self.repo_url = repo_url\n        self.branch = branch\n        self.temp_dir = None\n        self.repo = None\n    \n    def clone_repository(self) -> str:\n        \"\"\"Clone the Git repository to a temporary directory\"\"\"\n        self.temp_dir = tempfile.mkdtemp(prefix='nkwiki_')\n        print(f\"Cloning repository {self.repo_url} to {self.temp_dir}...\")\n        \n        try:\n            self.repo = git.Repo.clone_from(self.repo_url, self.temp_dir)\n            \n            # Checkout specific branch if provided\n            if self.branch != 'main':\n                self.repo.git.checkout(self.branch)\n            \n            return self.temp_dir\n        except git.GitCommandError as e:\n            if self.temp_dir and os.path.exists(self.temp_dir):\n                shutil.rmtree(self.temp_dir)\n            raise RuntimeError(f\"Failed to clone repository: {str(e)}\")\n    \n    def get_repository_info(self) -> Dict[str, Any]:\n        \"\"\"Get information about the Git repository\"\"\"\n        if not self.repo:\n            raise RuntimeError(\"Repository not cloned yet. Call clone_repository() first.\")\n        \n        # Get basic repository information\n        info = {\n            'url': self.repo_url,\n            'branch': self.branch,\n            'last_commit': {\n                'hash': self.repo.head.commit.hexsha,\n                'author': f\"{self.repo.head.commit.author.name} <{self.repo.head.commit.author.email}>\",\n                'date': self.repo.head.commit.committed_datetime.isoformat(),\n                'message': self.repo.head.commit.message.strip()\n            },\n            'contributors': self._get_contributors(),\n            'tags': [tag.name for tag in self.repo.tags]\n        }\n        \n        return info\n    \n    def _get_contributors(self) -> list:\n        \"\"\"Get list of contributors to the repository\"\"\"\n        contributors = {}\n        for commit in self.repo.iter_commits():\n            author = f\"{commit.author.name} <{commit.author.email}>\"\n            if author in contributors:\n                contributors[author]['commits'] += 1\n            else:\n                contributors[author] = {\n                    'name': commit.author.name,\n                    'email': commit.author.email,\n                    'commits': 1\n                }\n        \n        # Convert to list and sort by number of commits\n        contributors_list = list(contributors.values())\n        contributors_list.sort(key=lambda x: x['commits'], reverse=True)\n        \n        return contributors_list\n    \n    def cleanup(self) -> None:\n        \"\"\"Clean up temporary directory\"\"\"\n        if self.temp_dir and os.path.exists(self.temp_dir):\n            shutil.rmtree(self.temp_dir)\n            self.temp_dir = None\n            self.repo = None\n    \n    def __enter__(self):\n        self.clone_repository()\n        return self\n    \n    def __exit__(self, exc_type, exc_val, exc_tb):\n        self.cleanup()\n```\n\n3. Update the CLI to support Git repository URLs:\n```python\n# Update in cli/main.py\n\n# In parse_args function\nanalyze_parser.add_argument('--git', action='store_true', help='Treat path as a Git repository URL')\ngenerate_parser.add_argument('--git', action='store_true', help='Treat path as a Git repository URL')\ngenerate_parser.add_argument('--branch', default='main', help='Git branch to analyze (only with --git)')\n\n# In analyze_command and generate_command functions\ndef analyze_command(args: argparse.Namespace) -> int:\n    \"\"\"Execute the analyze command\"\"\"\n    path = args.path\n    \n    if args.git:\n        # Handle Git repository\n        from nkwiki.analyzer.git_analyzer import GitAnalyzer\n        try:\n            with GitAnalyzer(path, args.branch if hasattr(args, 'branch') else 'main') as git_analyzer:\n                path = git_analyzer.temp_dir\n                git_info = git_analyzer.get_repository_info()\n                \n                # Continue with analysis using the cloned repository path\n                # ... existing analysis code ...\n                \n                # Add Git info to analysis data\n                analysis_data['git'] = git_info\n        except Exception as e:\n            print(f\"Error analyzing Git repository: {str(e)}\", file=sys.stderr)\n            return 1\n    else:\n        # Handle local path (existing code)\n        path = os.path.abspath(path)\n        if not os.path.exists(path):\n            print(f\"Error: Path '{path}' does not exist\", file=sys.stderr)\n            return 1\n        \n        # ... existing analysis code ...\n```\n\n4. Update the markdown generator to include Git repository information:\n```python\n# In MarkdownGenerator._generate_overview method\ndef _generate_overview(self) -> None:\n    \"\"\"Generate project overview documentation\"\"\"\n    overview_path = os.path.join(self.output_dir, 'overview.md')\n    \n    with open(overview_path, 'w', encoding='utf-8') as f:\n        f.write('# Project Overview\\n\\n')\n        \n        # Git repository information if available\n        if 'git' in self.analysis_data:\n            git_info = self.analysis_data['git']\n            f.write('## Repository Information\\n\\n')\n            f.write(f'- **Repository URL**: {git_info[\"url\"]}\\n')\n            f.write(f'- **Branch**: {git_info[\"branch\"]}\\n')\n            f.write(f'- **Last Commit**: {git_info[\"last_commit\"][\"hash\"]}\\n')\n            f.write(f'  - **Author**: {git_info[\"last_commit\"][\"author\"]}\\n')\n            f.write(f'  - **Date**: {git_info[\"last_commit\"][\"date\"]}\\n')\n            f.write(f'  - **Message**: {git_info[\"last_commit\"][\"message\"]}\\n\\n')\n            \n            f.write('### Top Contributors\\n\\n')\n            for contributor in git_info['contributors'][:5]:  # Show top 5 contributors\n                f.write(f'- {contributor[\"name\"]} ({contributor[\"commits\"]} commits)\\n')\n            f.write('\\n')\n        \n        # ... rest of the overview generation code ...\n```",
      "testStrategy": "1. Test with various Git repository URLs:\n   - Public GitHub repositories\n   - Private repositories (with authentication)\n   - Repositories with different structures\n2. Test branch selection functionality\n3. Verify correct extraction of Git metadata:\n   - Repository URL and branch\n   - Commit information\n   - Contributors list\n4. Test error handling for invalid repositories or network issues\n5. Verify cleanup of temporary directories\n6. Test integration with the existing analysis and documentation generation flow",
      "priority": "medium",
      "dependencies": [
        1,
        2,
        3
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 8,
      "title": "Implement Basic HTML Document Generator",
      "description": "Create a component that generates HTML documentation from the analyzed code structure",
      "details": "1. Add Jinja2 to requirements.txt\n2. Create HTML templates directory structure:\n```\nnkwiki/\n  ├── generator/\n  │   ├── templates/\n  │   │   ├── base.html\n  │   │   ├── index.html\n  │   │   ├── overview.html\n  │   │   └── module.html\n  │   └── static/\n  │       ├── css/\n  │       │   └── style.css\n  │       └── js/\n  │           └── main.js\n```\n\n3. Create HTML generator module:\n```python\n# nkwiki/generator/html_generator.py\nimport os\nimport shutil\nfrom typing import Dict, Any\nfrom jinja2 import Environment, FileSystemLoader\n\nclass HTMLGenerator:\n    def __init__(self, analysis_data: Dict[str, Any], output_dir: str):\n        self.analysis_data = analysis_data\n        self.output_dir = output_dir\n        \n        # Setup Jinja2 environment\n        template_dir = os.path.join(os.path.dirname(__file__), 'templates')\n        self.env = Environment(loader=FileSystemLoader(template_dir))\n    \n    def generate_documentation(self) -> None:\n        \"\"\"Generate HTML documentation from analysis data\"\"\"\n        os.makedirs(self.output_dir, exist_ok=True)\n        \n        # Copy static files\n        self._copy_static_files()\n        \n        # Generate index page\n        self._generate_index()\n        \n        # Generate overview page\n        self._generate_overview()\n        \n        # Generate module pages\n        self._generate_modules_docs()\n    \n    def _copy_static_files(self) -> None:\n        \"\"\"Copy static files to output directory\"\"\"\n        static_src = os.path.join(os.path.dirname(__file__), 'static')\n        static_dest = os.path.join(self.output_dir, 'static')\n        \n        if os.path.exists(static_src):\n            if os.path.exists(static_dest):\n                shutil.rmtree(static_dest)\n            shutil.copytree(static_src, static_dest)\n    \n    def _generate_index(self) -> None:\n        \"\"\"Generate index page\"\"\"\n        template = self.env.get_template('index.html')\n        \n        modules = []\n        for module_path in self.analysis_data['code'].keys():\n            module_name = os.path.splitext(os.path.basename(module_path))[0]\n            modules.append({\n                'name': module_name,\n                'path': module_path,\n                'url': f'modules/{module_name}.html'\n            })\n        \n        context = {\n            'title': 'Documentation Index',\n            'modules': modules\n        }\n        \n        output = template.render(**context)\n        with open(os.path.join(self.output_dir, 'index.html'), 'w', encoding='utf-8') as f:\n            f.write(output)\n    \n    def _generate_overview(self) -> None:\n        \"\"\"Generate overview page\"\"\"\n        template = self.env.get_template('overview.html')\n        \n        context = {\n            'title': 'Project Overview',\n            'project': self.analysis_data['project'],\n            'git': self.analysis_data.get('git')\n        }\n        \n        output = template.render(**context)\n        with open(os.path.join(self.output_dir, 'overview.html'), 'w', encoding='utf-8') as f:\n            f.write(output)\n    \n    def _generate_modules_docs(self) -> None:\n        \"\"\"Generate documentation for each module\"\"\"\n        template = self.env.get_template('module.html')\n        modules_dir = os.path.join(self.output_dir, 'modules')\n        os.makedirs(modules_dir, exist_ok=True)\n        \n        for module_path, module_data in self.analysis_data['code'].items():\n            module_name = os.path.splitext(os.path.basename(module_path))[0]\n            \n            context = {\n                'title': f'Module: {module_name}',\n                'module_name': module_name,\n                'module_path': module_path,\n                'module_data': module_data\n            }\n            \n            output = template.render(**context)\n            with open(os.path.join(modules_dir, f'{module_name}.html'), 'w', encoding='utf-8') as f:\n                f.write(output)\n```\n\n4. Create base HTML template:\n```html\n<!-- templates/base.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>{{ title }} - nkwiki Documentation</title>\n    <link rel=\"stylesheet\" href=\"{{ '../' if in_module else '' }}static/css/style.css\">\n    <link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css\">\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js\"></script>\n    <script>hljs.highlightAll();</script>\n</head>\n<body>\n    <header>\n        <div class=\"container\">\n            <h1>nkwiki Documentation</h1>\n            <nav>\n                <ul>\n                    <li><a href=\"{{ '../' if in_module else '' }}index.html\">Home</a></li>\n                    <li><a href=\"{{ '../' if in_module else '' }}overview.html\">Overview</a></li>\n                </ul>\n            </nav>\n        </div>\n    </header>\n    \n    <main class=\"container\">\n        <h1>{{ title }}</h1>\n        {% block content %}{% endblock %}\n    </main>\n    \n    <footer>\n        <div class=\"container\">\n            <p>Generated by nkwiki</p>\n        </div>\n    </footer>\n    \n    <script src=\"{{ '../' if in_module else '' }}static/js/main.js\"></script>\n</body>\n</html>\n```\n\n5. Update CLI to support HTML format:\n```python\n# In cli/main.py\n\n# Update in parse_args function\ngenerate_parser.add_argument('-f', '--format', default='markdown', \n                            choices=['markdown', 'html'], \n                            help='Documentation format')\n\n# In generate_command function\ndef generate_command(args: argparse.Namespace) -> int:\n    # ... existing code ...\n    \n    # Generate documentation\n    if args.format == 'markdown':\n        from nkwiki.generator.markdown_generator import MarkdownGenerator\n        generator = MarkdownGenerator(analysis_data, output_dir)\n        generator.generate_documentation()\n    elif args.format == 'html':\n        from nkwiki.generator.html_generator import HTMLGenerator\n        generator = HTMLGenerator(analysis_data, output_dir)\n        generator.generate_documentation()\n    \n    print(f\"Documentation generated successfully in '{output_dir}'\")\n    return 0\n```",
      "testStrategy": "1. Test HTML generation with sample analysis data\n2. Verify correct generation of:\n   - Index page with links to all modules\n   - Overview page with project structure\n   - Module pages with classes and functions\n3. Test with different browsers to ensure compatibility\n4. Verify that syntax highlighting works correctly\n5. Test navigation between pages\n6. Validate HTML output for standards compliance\n7. Test with edge cases like modules with no docstrings, empty classes, etc.",
      "priority": "medium",
      "dependencies": [
        4
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 9,
      "title": "Implement Basic Diagram Generation",
      "description": "Add functionality to generate basic diagrams for project structure and module relationships",
      "details": "1. Add graphviz to requirements.txt\n2. Create a diagram generator module:\n```python\n# nkwiki/generator/diagram_generator.py\nimport os\nfrom typing import Dict, Any, List\nimport graphviz\n\nclass DiagramGenerator:\n    def __init__(self, analysis_data: Dict[str, Any], output_dir: str):\n        self.analysis_data = analysis_data\n        self.output_dir = output_dir\n        self.diagrams_dir = os.path.join(output_dir, 'diagrams')\n        os.makedirs(self.diagrams_dir, exist_ok=True)\n    \n    def generate_all_diagrams(self) -> Dict[str, str]:\n        \"\"\"Generate all diagrams and return paths\"\"\"\n        diagram_paths = {}\n        \n        # Generate project structure diagram\n        structure_path = self.generate_structure_diagram()\n        if structure_path:\n            diagram_paths['structure'] = structure_path\n        \n        # Generate module relationships diagram\n        modules_path = self.generate_module_relationships()\n        if modules_path:\n            diagram_paths['modules'] = modules_path\n        \n        # Generate class diagrams for each module with classes\n        class_diagrams = self.generate_class_diagrams()\n        if class_diagrams:\n            diagram_paths['classes'] = class_diagrams\n        \n        return diagram_paths\n    \n    def generate_structure_diagram(self) -> str:\n        \"\"\"Generate project structure diagram\"\"\"\n        dot = graphviz.Digraph('project_structure', comment='Project Structure')\n        dot.attr('node', shape='box', style='filled', fillcolor='lightblue')\n        \n        # Add root node\n        root_name = os.path.basename(self.analysis_data['project']['hierarchy']['name'])\n        dot.node('root', root_name)\n        \n        # Add directory nodes and edges\n        self._add_directory_nodes(dot, self.analysis_data['project']['hierarchy'], 'root', [])\n        \n        # Save diagram\n        output_path = os.path.join(self.diagrams_dir, 'project_structure')\n        dot.render(output_path, format='png', cleanup=True)\n        \n        return os.path.relpath(f'{output_path}.png', self.output_dir)\n    \n    def _add_directory_nodes(self, dot, node, parent_id, added_nodes, prefix=''):\n        \"\"\"Recursively add directory nodes to the graph\"\"\"\n        if 'children' not in node:\n            return\n        \n        for child in node['children']:\n            child_name = child['name']\n            child_id = f\"{prefix}_{child_name}\" if prefix else child_name\n            \n            # Skip hidden files/directories\n            if child_name.startswith('.'):\n                continue\n            \n            # Skip already added nodes\n            if child_id in added_nodes:\n                continue\n            \n            added_nodes.append(child_id)\n            \n            if child['type'] == 'dir':\n                dot.node(child_id, child_name, fillcolor='lightblue')\n                dot.edge(parent_id, child_id)\n                self._add_directory_nodes(dot, child, child_id, added_nodes, child_id)\n            elif child['type'] == 'file' and child_name.endswith('.py'):\n                dot.node(child_id, child_name, fillcolor='lightgreen')\n                dot.edge(parent_id, child_id)\n    \n    def generate_module_relationships(self) -> str:\n        \"\"\"Generate module relationships diagram\"\"\"\n        dot = graphviz.Digraph('module_relationships', comment='Module Relationships')\n        dot.attr('node', shape='box', style='filled', fillcolor='lightblue')\n        \n        # Add module nodes\n        modules = {}\n        for module_path, module_data in self.analysis_data['code'].items():\n            module_name = os.path.splitext(os.path.basename(module_path))[0]\n            module_id = f\"module_{module_name}\"\n            dot.node(module_id, module_name)\n            modules[module_path] = module_id\n        \n        # Add edges based on imports\n        for module_path, module_data in self.analysis_data['code'].items():\n            if 'imports' not in module_data:\n                continue\n                \n            source_id = modules[module_path]\n            \n            for imp in module_data['imports']:\n                # Try to find the target module in our analyzed modules\n                for target_path in modules.keys():\n                    target_name = os.path.splitext(os.path.basename(target_path))[0]\n                    if imp['name'] == target_name or imp['name'].endswith(f'.{target_name}'):\n                        target_id = modules[target_path]\n                        dot.edge(source_id, target_id)\n        \n        # Save diagram\n        output_path = os.path.join(self.diagrams_dir, 'module_relationships')\n        dot.render(output_path, format='png', cleanup=True)\n        \n        return os.path.relpath(f'{output_path}.png', self.output_dir)\n    \n    def generate_class_diagrams(self) -> Dict[str, str]:\n        \"\"\"Generate class diagrams for each module with classes\"\"\"\n        class_diagrams = {}\n        \n        for module_path, module_data in self.analysis_data['code'].items():\n            if not module_data.get('classes'):\n                continue\n                \n            module_name = os.path.splitext(os.path.basename(module_path))[0]\n            \n            dot = graphviz.Digraph(f'class_diagram_{module_name}', \n                                  comment=f'Class Diagram for {module_name}')\n            dot.attr('node', shape='record', style='filled', fillcolor='lightblue')\n            \n            # Add class nodes\n            for class_info in module_data['classes']:\n                class_name = class_info['name']\n                methods = class_info.get('methods', [])\n                \n                # Create label with class name and methods\n                label = f\"{{{class_name}|{self._format_methods_for_diagram(methods)}}}\"\n                dot.node(class_name, label)\n                \n                # Add inheritance edges if available\n                if 'bases' in class_info:\n                    for base in class_info['bases']:\n                        # Check if base class is in our diagram\n                        for other_class in module_data['classes']:\n                            if other_class['name'] == base:\n                                dot.edge(base, class_name, arrowhead='empty')\n            \n            # Save diagram\n            output_path = os.path.join(self.diagrams_dir, f'class_diagram_{module_name}')\n            dot.render(output_path, format='png', cleanup=True)\n            \n            class_diagrams[module_name] = os.path.relpath(f'{output_path}.png', self.output_dir)\n        \n        return class_diagrams\n    \n    def _format_methods_for_diagram(self, methods: List[Dict[str, Any]]) -> str:\n        \"\"\"Format methods for display in class diagram\"\"\"\n        if not methods:\n            return \"\"\n            \n        result = []\n        for method in methods:\n            method_name = method['name']\n            # Skip private methods\n            if method_name.startswith('_') and not method_name.startswith('__'):\n                continue\n                \n            result.append(method_name + '()')\n            \n        return '\\\\l'.join(result) + '\\\\l'  # Left-align text\n```\n\n3. Integrate diagram generation with HTML generator:\n```python\n# In HTMLGenerator class\nfrom nkwiki.generator.diagram_generator import DiagramGenerator\n\ndef generate_documentation(self) -> None:\n    \"\"\"Generate HTML documentation from analysis data\"\"\"\n    os.makedirs(self.output_dir, exist_ok=True)\n    \n    # Generate diagrams\n    diagram_generator = DiagramGenerator(self.analysis_data, self.output_dir)\n    diagrams = diagram_generator.generate_all_diagrams()\n    \n    # Add diagrams to analysis data for templates\n    self.analysis_data['diagrams'] = diagrams\n    \n    # Copy static files\n    self._copy_static_files()\n    \n    # Generate pages\n    self._generate_index()\n    self._generate_overview()\n    self._generate_modules_docs()\n```\n\n4. Update HTML templates to include diagrams:\n```html\n<!-- In overview.html template -->\n{% extends \"base.html\" %}\n{% set in_module = false %}\n\n{% block content %}\n    <!-- Project structure section -->\n    <section>\n        <h2>Project Structure</h2>\n        \n        {% if diagrams and diagrams.structure %}\n            <div class=\"diagram\">\n                <img src=\"{{ diagrams.structure }}\" alt=\"Project Structure Diagram\">\n            </div>\n        {% endif %}\n        \n        <!-- Rest of the overview content -->\n    </section>\n{% endblock %}\n\n<!-- In module.html template -->\n{% if diagrams and diagrams.classes and module_name in diagrams.classes %}\n    <section>\n        <h2>Class Diagram</h2>\n        <div class=\"diagram\">\n            <img src=\"../{{ diagrams.classes[module_name] }}\" alt=\"Class Diagram for {{ module_name }}\">\n        </div>\n    </section>\n{% endif %}\n```\n\n5. Update markdown generator to include diagrams:\n```python\n# In MarkdownGenerator class\nfrom nkwiki.generator.diagram_generator import DiagramGenerator\n\ndef generate_documentation(self) -> None:\n    \"\"\"Generate markdown documentation from analysis data\"\"\"\n    os.makedirs(self.output_dir, exist_ok=True)\n    \n    # Generate diagrams\n    diagram_generator = DiagramGenerator(self.analysis_data, self.output_dir)\n    diagrams = diagram_generator.generate_all_diagrams()\n    \n    # Add diagrams to analysis data\n    self.analysis_data['diagrams'] = diagrams\n    \n    # Generate documentation\n    self._generate_overview()\n    self._generate_modules_docs()\n    self._generate_index()\n\ndef _generate_overview(self) -> None:\n    # ... existing code ...\n    \n    # Add diagrams section if available\n    if 'diagrams' in self.analysis_data and self.analysis_data['diagrams'].get('structure'):\n        f.write('## Project Structure Diagram\\n\\n')\n        f.write(f'![Project Structure Diagram]({self.analysis_data[\"diagrams\"][\"structure\"]})\\n\\n')\n    \n    if 'diagrams' in self.analysis_data and self.analysis_data['diagrams'].get('modules'):\n        f.write('## Module Relationships Diagram\\n\\n')\n        f.write(f'![Module Relationships Diagram]({self.analysis_data[\"diagrams\"][\"modules\"]})\\n\\n')\n```",
      "testStrategy": "1. Test diagram generation with sample projects of varying complexity\n2. Verify correct generation of:\n   - Project structure diagrams\n   - Module relationship diagrams\n   - Class diagrams\n3. Test integration with both HTML and Markdown generators\n4. Verify that diagrams are correctly referenced in generated documentation\n5. Test with edge cases like projects with circular dependencies\n6. Verify that diagrams are visually clear and properly formatted\n7. Test with large projects to ensure diagrams remain readable",
      "priority": "low",
      "dependencies": [
        3,
        4,
        8
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 10,
      "title": "Implement Comprehensive Testing Suite",
      "description": "Create a comprehensive testing suite to validate all components of the nkwiki tool",
      "details": "1. Add pytest, pytest-cov, and pytest-mock to requirements.txt\n2. Create test directory structure:\n```\ntests/\n  ├── __init__.py\n  ├── conftest.py\n  ├── test_analyzer/\n  │   ├── __init__.py\n  │   ├── test_python_analyzer.py\n  │   ├── test_project_analyzer.py\n  │   ├── test_example_extractor.py\n  │   └── test_git_analyzer.py\n  ├── test_generator/\n  │   ├── __init__.py\n  │   ├── test_markdown_generator.py\n  │   ├── test_html_generator.py\n  │   └── test_diagram_generator.py\n  ├── test_cli/\n  │   ├── __init__.py\n  │   └── test_main.py\n  └── fixtures/\n      ├── sample_project/\n      │   ├── __init__.py\n      │   ├── module1.py\n      │   └── module2.py\n      └── sample_docstrings.py\n```\n\n3. Create conftest.py with common fixtures:\n```python\n# tests/conftest.py\nimport os\nimport tempfile\nimport shutil\nimport pytest\n\n@pytest.fixture\ndef temp_dir():\n    \"\"\"Create a temporary directory for test outputs\"\"\"\n    temp_dir = tempfile.mkdtemp()\n    yield temp_dir\n    shutil.rmtree(temp_dir)\n\n@pytest.fixture\ndef sample_project_path():\n    \"\"\"Path to the sample project in fixtures\"\"\"\n    return os.path.join(os.path.dirname(__file__), 'fixtures', 'sample_project')\n\n@pytest.fixture\ndef sample_analysis_data():\n    \"\"\"Sample analysis data for testing generators\"\"\"\n    return {\n        'project': {\n            'hierarchy': {\n                'name': 'sample_project',\n                'type': 'dir',\n                'children': [\n                    {'name': '__init__.py', 'type': 'file', 'path': '__init__.py'},\n                    {'name': 'module1.py', 'type': 'file', 'path': 'module1.py'},\n                    {'name': 'module2.py', 'type': 'file', 'path': 'module2.py'}\n                ]\n            },\n            'directories': [],\n            'config_files': []\n        },\n        'code': {\n            'module1.py': {\n                'docstring': 'Module 1 docstring',\n                'classes': [\n                    {\n                        'name': 'Class1',\n                        'docstring': 'Class1 docstring',\n                        'methods': [\n                            {\n                                'name': 'method1',\n                                'docstring': 'Method1 docstring',\n                                'signature': 'def method1(self, arg1: str) -> None:'\n                            }\n                        ]\n                    }\n                ],\n                'functions': [\n                    {\n                        'name': 'function1',\n                        'docstring': 'Function1 docstring',\n                        'signature': 'def function1(arg1: int, arg2: str = \"default\") -> bool:',\n                        'examples': [\n                            {\n                                'type': 'code_block',\n                                'code': 'result = function1(42, \"test\")',\n                                'output': None\n                            }\n                        ]\n                    }\n                ],\n                'imports': []\n            },\n            'module2.py': {\n                'docstring': 'Module 2 docstring',\n                'classes': [],\n                'functions': [\n                    {\n                        'name': 'function2',\n                        'docstring': 'Function2 docstring',\n                        'signature': 'def function2() -> None:'\n                    }\n                ],\n                'imports': [\n                    {'name': 'module1', 'alias': None}\n                ]\n            }\n        }\n    }\n```\n\n4. Create sample test files for analyzers:\n```python\n# tests/test_analyzer/test_python_analyzer.py\nimport os\nimport ast\nimport pytest\nfrom nkwiki.analyzer.python_analyzer import PythonAnalyzer\n\ndef test_analyze_file(sample_project_path):\n    \"\"\"Test analyzing a single Python file\"\"\"\n    analyzer = PythonAnalyzer(sample_project_path)\n    file_path = os.path.join(sample_project_path, 'module1.py')\n    \n    result = analyzer.analyze_file(file_path)\n    \n    assert 'docstring' in result\n    assert 'classes' in result\n    assert 'functions' in result\n    assert 'imports' in result\n\ndef test_analyze_directory(sample_project_path):\n    \"\"\"Test analyzing a directory of Python files\"\"\"\n    analyzer = PythonAnalyzer(sample_project_path)\n    \n    result = analyzer.analyze_directory()\n    \n    assert 'module1.py' in result\n    assert 'module2.py' in result\n    assert '__init__.py' in result\n\ndef test_extract_classes():\n    \"\"\"Test extracting classes from AST\"\"\"\n    code = \"\"\"\n    class TestClass:\n        \"\"\"Test class docstring\"\"\"\n        def __init__(self, arg1):\n            self.arg1 = arg1\n            \n        def test_method(self):\n            \"\"\"Test method docstring\"\"\"\n            return self.arg1\n    \"\"\"\n    \n    tree = ast.parse(code)\n    analyzer = PythonAnalyzer('')\n    \n    classes = analyzer._extract_classes(tree)\n    \n    assert len(classes) == 1\n    assert classes[0]['name'] == 'TestClass'\n    assert classes[0]['docstring'] == 'Test class docstring'\n    assert len(classes[0]['methods']) == 2  # __init__ and test_method\n\ndef test_extract_functions():\n    \"\"\"Test extracting functions from AST\"\"\"\n    code = \"\"\"\n    def test_function(arg1, arg2=None):\n        \"\"\"Test function docstring\"\"\"\n        return arg1 + arg2\n    \"\"\"\n    \n    tree = ast.parse(code)\n    analyzer = PythonAnalyzer('')\n    \n    functions = analyzer._extract_functions(tree)\n    \n    assert len(functions) == 1\n    assert functions[0]['name'] == 'test_function'\n    assert functions[0]['docstring'] == 'Test function docstring'\n    assert 'arg1' in functions[0]['signature']\n    assert 'arg2=None' in functions[0]['signature']\n```\n\n5. Create sample test files for generators:\n```python\n# tests/test_generator/test_markdown_generator.py\nimport os\nimport pytest\nfrom nkwiki.generator.markdown_generator import MarkdownGenerator\n\ndef test_generate_documentation(temp_dir, sample_analysis_data):\n    \"\"\"Test generating markdown documentation\"\"\"\n    generator = MarkdownGenerator(sample_analysis_data, temp_dir)\n    generator.generate_documentation()\n    \n    # Check that expected files were created\n    assert os.path.exists(os.path.join(temp_dir, 'index.md'))\n    assert os.path.exists(os.path.join(temp_dir, 'overview.md'))\n    assert os.path.exists(os.path.join(temp_dir, 'modules'))\n    assert os.path.exists(os.path.join(temp_dir, 'modules', 'module1.md'))\n    assert os.path.exists(os.path.join(temp_dir, 'modules', 'module2.md'))\n\ndef test_generate_overview(temp_dir, sample_analysis_data):\n    \"\"\"Test generating overview documentation\"\"\"\n    generator = MarkdownGenerator(sample_analysis_data, temp_dir)\n    generator._generate_overview()\n    \n    overview_path = os.path.join(temp_dir, 'overview.md')\n    assert os.path.exists(overview_path)\n    \n    with open(overview_path, 'r', encoding='utf-8') as f:\n        content = f.read()\n        assert '# Project Overview' in content\n        assert '## Project Structure' in content\n\ndef test_generate_modules_docs(temp_dir, sample_analysis_data):\n    \"\"\"Test generating module documentation\"\"\"\n    generator = MarkdownGenerator(sample_analysis_data, temp_dir)\n    os.makedirs(os.path.join(temp_dir, 'modules'), exist_ok=True)\n    generator._generate_modules_docs()\n    \n    module1_path = os.path.join(temp_dir, 'modules', 'module1.md')\n    assert os.path.exists(module1_path)\n    \n    with open(module1_path, 'r', encoding='utf-8') as f:\n        content = f.read()\n        assert '# Module: module1' in content\n        assert 'Module 1 docstring' in content\n        assert '## Classes' in content\n        assert '### Class1' in content\n        assert '## Functions' in content\n        assert '### `function1`' in content\n```\n\n6. Create sample test files for CLI:\n```python\n# tests/test_cli/test_main.py\nimport os\nimport pytest\nfrom unittest.mock import patch\nfrom nkwiki.cli.main import main, parse_args\n\ndef test_parse_args():\n    \"\"\"Test argument parsing\"\"\"\n    args = parse_args(['analyze', '/path/to/code'])\n    assert args.command == 'analyze'\n    assert args.path == '/path/to/code'\n    assert args.output is None\n    \n    args = parse_args(['generate', '/path/to/code', '-o', '/output/dir', '-f', 'html'])\n    assert args.command == 'generate'\n    assert args.path == '/path/to/code'\n    assert args.output == '/output/dir'\n    assert args.format == 'html'\n    \n    args = parse_args(['version'])\n    assert args.command == 'version'\n\n@patch('nkwiki.cli.main.analyze_command')\ndef test_main_analyze(mock_analyze):\n    \"\"\"Test main function with analyze command\"\"\"\n    mock_analyze.return_value = 0\n    \n    result = main(['analyze', '/path/to/code'])\n    \n    assert result == 0\n    mock_analyze.assert_called_once()\n\n@patch('nkwiki.cli.main.generate_command')\ndef test_main_generate(mock_generate):\n    \"\"\"Test main function with generate command\"\"\"\n    mock_generate.return_value = 0\n    \n    result = main(['generate', '/path/to/code'])\n    \n    assert result == 0\n    mock_generate.assert_called_once()\n\n@patch('nkwiki.cli.main.PythonAnalyzer')\n@patch('nkwiki.cli.main.ProjectAnalyzer')\ndef test_analyze_command(mock_project_analyzer, mock_python_analyzer, temp_dir):\n    \"\"\"Test analyze command\"\"\"\n    from nkwiki.cli.main import analyze_command\n    import argparse\n    \n    # Setup mocks\n    mock_project_analyzer_instance = mock_project_analyzer.return_value\n    mock_project_analyzer_instance.analyze_structure.return_value = {'test': 'project'}\n    \n    mock_python_analyzer_instance = mock_python_analyzer.return_value\n    mock_python_analyzer_instance.analyze_directory.return_value = {'test': 'code'}\n    \n    # Create args\n    args = argparse.Namespace()\n    args.path = temp_dir\n    args.output = os.path.join(temp_dir, 'analysis.json')\n    args.git = False\n    \n    # Run command\n    result = analyze_command(args)\n    \n    # Verify\n    assert result == 0\n    mock_project_analyzer.assert_called_once_with(temp_dir)\n    mock_python_analyzer.assert_called_once_with(temp_dir)\n    assert os.path.exists(args.output)\n```\n\n7. Create a setup.cfg file for pytest configuration:\n```ini\n[tool:pytest]\npython_files = test_*.py\npython_classes = Test*\npython_functions = test_*\ntestpaths = tests\n\n[coverage:run]\nsource = nkwiki\nomit = tests/*\n```\n\n8. Add a Makefile for common test commands:\n```makefile\n.PHONY: test test-cov lint clean\n\ntest:\n\tpytest\n\ntest-cov:\n\tpytest --cov=nkwiki --cov-report=term --cov-report=html\n\nlint:\n\tflake8 nkwiki tests\n\nclean:\n\trm -rf .coverage htmlcov .pytest_cache\n```",
      "testStrategy": "1. Run unit tests for each component:\n   - Code analyzers (Python, Project, Git)\n   - Document generators (Markdown, HTML)\n   - Diagram generator\n   - CLI interface\n2. Run integration tests to verify end-to-end functionality:\n   - Analyze a sample project and generate documentation\n   - Test with different output formats\n   - Test with Git repositories\n3. Test with edge cases:\n   - Empty projects\n   - Projects with syntax errors\n   - Large projects\n   - Projects with unusual structures\n4. Measure code coverage and aim for at least 80% coverage\n5. Run tests on different platforms (Windows, macOS, Linux)\n6. Verify that generated documentation is valid and well-formatted",
      "priority": "high",
      "dependencies": [
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9
      ],
      "status": "pending",
      "subtasks": []
    }
  ]
}